   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"keyboard.c"
  21              	.Ltext0:
  22              		.file 1 "../keyboard.c"
 2730              		.align	2
 2733              	keyboard_base:
 2734 0000 00000006 		.word	100663296
 2735              		.comm	key,4,4
 2736              		.text
 2737              		.align	2
 2738              		.global	keyboard_init
 2740              	keyboard_init:
 2741              	.LFB0:
   1:../keyboard.c **** /*--- Ficheros de cabecera ---*/
   2:../keyboard.c **** #include "44b.h"
   3:../keyboard.c **** #include "44blib.h"
   4:../keyboard.c **** #include "def.h"
   5:../keyboard.c **** #include "uart.h"
   6:../keyboard.c **** //#include "playerMovement.h"
   7:../keyboard.c **** 
   8:../keyboard.c **** 
   9:../keyboard.c **** extern const int NCOL;
  10:../keyboard.c **** extern int tablero[];
  11:../keyboard.c **** extern int turno;
  12:../keyboard.c **** extern int comprobarFinDelJuego();
  13:../keyboard.c **** 
  14:../keyboard.c **** /*--- Definición de macros ---*/
  15:../keyboard.c **** #define KEY_VALUE_MASK 0xF
  16:../keyboard.c **** /*--- Variables globales ---*/
  17:../keyboard.c **** volatile UCHAR *keyboard_base = (UCHAR *)0x06000000;
  18:../keyboard.c **** int key;
  19:../keyboard.c **** 
  20:../keyboard.c **** /*--- Funciones externas ---*/
  21:../keyboard.c **** void D8Led_symbol(int value);
  22:../keyboard.c **** extern void drawO(int posicion);
  23:../keyboard.c **** extern void drawX(int posicion);
  24:../keyboard.c **** 
  25:../keyboard.c **** /*--- Declaracion de funciones ---*/
  26:../keyboard.c **** void keyboard_init();
  27:../keyboard.c **** int key_read();
  28:../keyboard.c **** void KeyboardInt(void) __attribute__ ((interrupt ("IRQ")));
  29:../keyboard.c **** 
  30:../keyboard.c **** 
  31:../keyboard.c **** /*--- Codigo de las funciones ---*/
  32:../keyboard.c **** void keyboard_init()
  33:../keyboard.c **** {
 2742              		.loc 1 33 0
 2743              		.cfi_startproc
 2744              		@ Function supports interworking.
 2745              		@ args = 0, pretend = 0, frame = 0
 2746              		@ frame_needed = 1, uses_anonymous_args = 0
 2747 0000 0DC0A0E1 		mov	ip, sp
 2748              	.LCFI0:
 2749              		.cfi_def_cfa_register 12
 2750 0004 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2751 0008 04B04CE2 		sub	fp, ip, #4
 2752              		.cfi_offset 14, -8
 2753              		.cfi_offset 13, -12
 2754              		.cfi_offset 11, -16
 2755              	.LCFI1:
 2756              		.cfi_def_cfa 11, 4
  34:../keyboard.c **** 	/* Configurar el puerto G (si no lo estuviese ya) */	
  35:../keyboard.c **** 	// Establece la funcion de los pines (EINT0-7)
  36:../keyboard.c **** 	rPCONG |= 0xC;
 2757              		.loc 1 36 0
 2758 000c 80309FE5 		ldr	r3, .L2
 2759 0010 7C209FE5 		ldr	r2, .L2
 2760 0014 002092E5 		ldr	r2, [r2, #0]
 2761 0018 0C2082E3 		orr	r2, r2, #12
 2762 001c 002083E5 		str	r2, [r3, #0]
  37:../keyboard.c **** 	//rPCONG |= (1<<2 | 1<<3);
  38:../keyboard.c **** 
  39:../keyboard.c **** 	// Habilita el "pull up" del puerto
  40:../keyboard.c **** 	rPUPG = 0x0;
 2763              		.loc 1 40 0
 2764 0020 70309FE5 		ldr	r3, .L2+4
 2765 0024 0020A0E3 		mov	r2, #0
 2766 0028 002083E5 		str	r2, [r3, #0]
  41:../keyboard.c **** 
  42:../keyboard.c **** 	/*
  43:../keyboard.c **** 		AÑADIMOS LAS INTERRUPCIONES
  44:../keyboard.c **** 	*/
  45:../keyboard.c **** 
  46:../keyboard.c **** 	// Configura las lineas de int. como de flanco de bajada mediante EXTINT
  47:../keyboard.c **** 	rEXTINT = 0x22222222;
 2767              		.loc 1 47 0
 2768 002c 68309FE5 		ldr	r3, .L2+8
 2769 0030 68209FE5 		ldr	r2, .L2+12
 2770 0034 002083E5 		str	r2, [r3, #0]
  48:../keyboard.c **** 
  49:../keyboard.c **** 	/* Establece la rutina de servicio para EINT1 */
  50:../keyboard.c **** 	pISR_EINT1 = (unsigned) KeyboardInt; // Funcion de arriba indicada para interrupciones
 2771              		.loc 1 50 0
 2772 0038 64309FE5 		ldr	r3, .L2+16
 2773 003c 64209FE5 		ldr	r2, .L2+20
 2774 0040 002083E5 		str	r2, [r3, #0]
  51:../keyboard.c **** 
  52:../keyboard.c **** 	/* Configurar controlador de interrupciones */
  53:../keyboard.c **** 	// Borra INTPND escribiendo 1s en I_ISPC
  54:../keyboard.c **** 	//rEXTINTPND = 0xf;
  55:../keyboard.c **** 	rI_ISPC = 0x3ffffff;
 2775              		.loc 1 55 0
 2776 0044 60309FE5 		ldr	r3, .L2+24
 2777 0048 3F23E0E3 		mvn	r2, #-67108864
 2778 004c 002083E5 		str	r2, [r3, #0]
  56:../keyboard.c **** 	// Configura las lineas como de tipo IRQ mediante INTMOD
  57:../keyboard.c **** 	rINTMOD = 0x0;
 2779              		.loc 1 57 0
 2780 0050 58309FE5 		ldr	r3, .L2+28
 2781 0054 0020A0E3 		mov	r2, #0
 2782 0058 002083E5 		str	r2, [r3, #0]
  58:../keyboard.c **** 	// Habilita int. vectorizadas y la linea IRQ (FIQ no) mediante INTCON
  59:../keyboard.c **** 	rINTCON = 0x1;
 2783              		.loc 1 59 0
 2784 005c 1E36A0E3 		mov	r3, #31457280
 2785 0060 0120A0E3 		mov	r2, #1
 2786 0064 002083E5 		str	r2, [r3, #0]
  60:../keyboard.c **** 
  61:../keyboard.c **** 	/* Habilitar linea EINT1 */
  62:../keyboard.c **** 	rINTMSK = rINTMSK & ~(BIT_EINT1 | BIT_GLOBAL);// Enmascarar todas las lineas excepto Eint1 y el bi
 2787              		.loc 1 62 0
 2788 0068 44309FE5 		ldr	r3, .L2+32
 2789 006c 40209FE5 		ldr	r2, .L2+32
 2790 0070 002092E5 		ldr	r2, [r2, #0]
 2791 0074 0524C2E3 		bic	r2, r2, #83886080
 2792 0078 002083E5 		str	r2, [r3, #0]
  63:../keyboard.c **** 
  64:../keyboard.c **** 	/* Por precaucion, se vuelven a borrar los bits de INTPND correspondientes*/
  65:../keyboard.c **** 	rI_ISPC = 0x3ffffff;
 2793              		.loc 1 65 0
 2794 007c 28309FE5 		ldr	r3, .L2+24
 2795 0080 3F23E0E3 		mvn	r2, #-67108864
 2796 0084 002083E5 		str	r2, [r3, #0]
  66:../keyboard.c **** }
 2797              		.loc 1 66 0
 2798 0088 0CD04BE2 		sub	sp, fp, #12
 2799 008c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2800 0090 1EFF2FE1 		bx	lr
 2801              	.L3:
 2802              		.align	2
 2803              	.L2:
 2804 0094 4000D201 		.word	30539840
 2805 0098 4800D201 		.word	30539848
 2806 009c 5000D201 		.word	30539856
 2807 00a0 22222222 		.word	572662306
 2808 00a4 80FF7F0C 		.word	209715072
 2809 00a8 00000000 		.word	KeyboardInt
 2810 00ac 2400E001 		.word	31457316
 2811 00b0 0800E001 		.word	31457288
 2812 00b4 0C00E001 		.word	31457292
 2813              		.cfi_endproc
 2814              	.LFE0:
 2816              		.align	2
 2817              		.global	KeyboardInt
 2819              	KeyboardInt:
 2820              	.LFB1:
  67:../keyboard.c **** 
  68:../keyboard.c **** 
  69:../keyboard.c **** void KeyboardInt(void)
  70:../keyboard.c **** {
 2821              		.loc 1 70 0
 2822              		.cfi_startproc
 2823              		@ Interrupt Service Routine.
 2824              		@ args = 0, pretend = 0, frame = 56
 2825              		@ frame_needed = 1, uses_anonymous_args = 0
 2826 00b8 04C02DE5 		str	ip, [sp, #-4]!
 2827 00bc 0DC0A0E1 		mov	ip, sp
 2828              	.LCFI2:
 2829              		.cfi_def_cfa_register 12
 2830 00c0 0FD82DE9 		stmfd	sp!, {r0, r1, r2, r3, fp, ip, lr, pc}
 2831 00c4 04B04CE2 		sub	fp, ip, #4
 2832              		.cfi_offset 14, -8
 2833              		.cfi_offset 13, -12
 2834              		.cfi_offset 11, -16
 2835              		.cfi_offset 3, -20
 2836              		.cfi_offset 2, -24
 2837              		.cfi_offset 1, -28
 2838              		.cfi_offset 0, -32
 2839              	.LCFI3:
 2840              		.cfi_def_cfa 11, 4
 2841 00c8 38D04DE2 		sub	sp, sp, #56
  71:../keyboard.c **** 
  72:../keyboard.c **** 	int aux[9];
  73:../keyboard.c **** 	int i;
  74:../keyboard.c **** 	for (i = 0; i < 9; i++){
 2842              		.loc 1 74 0
 2843 00cc 0030A0E3 		mov	r3, #0
 2844 00d0 20300BE5 		str	r3, [fp, #-32]
 2845 00d4 0C0000EA 		b	.L5
 2846              	.L6:
  75:../keyboard.c **** 		aux[i] = tablero[i];
 2847              		.loc 1 75 0 discriminator 2
 2848 00d8 4C329FE5 		ldr	r3, .L18
 2849 00dc 20201BE5 		ldr	r2, [fp, #-32]
 2850 00e0 022193E7 		ldr	r2, [r3, r2, asl #2]
 2851 00e4 20101BE5 		ldr	r1, [fp, #-32]
 2852 00e8 3330E0E3 		mvn	r3, #51
 2853 00ec 0111A0E1 		mov	r1, r1, asl #2
 2854 00f0 1C004BE2 		sub	r0, fp, #28
 2855 00f4 011080E0 		add	r1, r0, r1
 2856 00f8 033081E0 		add	r3, r1, r3
 2857 00fc 002083E5 		str	r2, [r3, #0]
  74:../keyboard.c **** 	for (i = 0; i < 9; i++){
 2858              		.loc 1 74 0 discriminator 2
 2859 0100 20301BE5 		ldr	r3, [fp, #-32]
 2860 0104 013083E2 		add	r3, r3, #1
 2861 0108 20300BE5 		str	r3, [fp, #-32]
 2862              	.L5:
  74:../keyboard.c **** 	for (i = 0; i < 9; i++){
 2863              		.loc 1 74 0 is_stmt 0 discriminator 1
 2864 010c 20301BE5 		ldr	r3, [fp, #-32]
 2865 0110 080053E3 		cmp	r3, #8
 2866 0114 EFFFFFDA 		ble	.L6
  76:../keyboard.c **** 	}
  77:../keyboard.c **** 	/* Esperar trp mediante la funcion DelayMs()*/
  78:../keyboard.c **** 	DelayMs(100);
 2867              		.loc 1 78 0 is_stmt 1
 2868 0118 6400A0E3 		mov	r0, #100
 2869 011c FEFFFFEB 		bl	DelayMs
  79:../keyboard.c **** 	/* Identificar la tecla */
  80:../keyboard.c **** 	key = 15;
 2870              		.loc 1 80 0
 2871 0120 08329FE5 		ldr	r3, .L18+4
 2872 0124 0F20A0E3 		mov	r2, #15
 2873 0128 002083E5 		str	r2, [r3, #0]
  81:../keyboard.c **** 	while (key > NCOL*NCOL || tablero[key] != 0 ){ // es como que deshabilitamos el resto de teclas...
 2874              		.loc 1 81 0
 2875 012c 0A0000EA 		b	.L7
 2876              	.L8:
 2877              	.LBB2:
  82:../keyboard.c **** 		key = key_read();
 2878              		.loc 1 82 0
 2879 0130 FEFFFFEB 		bl	key_read
 2880 0134 0020A0E1 		mov	r2, r0
 2881 0138 F0319FE5 		ldr	r3, .L18+4
 2882 013c 002083E5 		str	r2, [r3, #0]
  83:../keyboard.c **** 		int aux2 = tablero[key];
 2883              		.loc 1 83 0
 2884 0140 E8319FE5 		ldr	r3, .L18+4
 2885 0144 002093E5 		ldr	r2, [r3, #0]
 2886 0148 DC319FE5 		ldr	r3, .L18
 2887 014c 023193E7 		ldr	r3, [r3, r2, asl #2]
 2888 0150 24300BE5 		str	r3, [fp, #-36]
  84:../keyboard.c **** 		DelayMs(1);
 2889              		.loc 1 84 0
 2890 0154 0100A0E3 		mov	r0, #1
 2891 0158 FEFFFFEB 		bl	DelayMs
 2892              	.L7:
 2893              	.LBE2:
  81:../keyboard.c **** 	while (key > NCOL*NCOL || tablero[key] != 0 ){ // es como que deshabilitamos el resto de teclas...
 2894              		.loc 1 81 0 discriminator 1
 2895 015c D0319FE5 		ldr	r3, .L18+8
 2896 0160 003093E5 		ldr	r3, [r3, #0]
 2897 0164 C8219FE5 		ldr	r2, .L18+8
 2898 0168 002092E5 		ldr	r2, [r2, #0]
 2899 016c 930202E0 		mul	r2, r3, r2
 2900 0170 B8319FE5 		ldr	r3, .L18+4
 2901 0174 003093E5 		ldr	r3, [r3, #0]
 2902 0178 030052E1 		cmp	r2, r3
 2903 017c EBFFFFBA 		blt	.L8
  81:../keyboard.c **** 	while (key > NCOL*NCOL || tablero[key] != 0 ){ // es como que deshabilitamos el resto de teclas...
 2904              		.loc 1 81 0 is_stmt 0 discriminator 2
 2905 0180 A8319FE5 		ldr	r3, .L18+4
 2906 0184 002093E5 		ldr	r2, [r3, #0]
 2907 0188 9C319FE5 		ldr	r3, .L18
 2908 018c 023193E7 		ldr	r3, [r3, r2, asl #2]
 2909 0190 000053E3 		cmp	r3, #0
 2910 0194 E5FFFF1A 		bne	.L8
  85:../keyboard.c **** 	}
  86:../keyboard.c **** 
  87:../keyboard.c **** 	/* Si la tecla se ha identificado, visualizarla en el 8SEG*/
  88:../keyboard.c **** 	if(key > -1 && tablero[key] == 0)
 2911              		.loc 1 88 0 is_stmt 1
 2912 0198 90319FE5 		ldr	r3, .L18+4
 2913 019c 003093E5 		ldr	r3, [r3, #0]
 2914 01a0 000053E3 		cmp	r3, #0
 2915 01a4 4A0000BA 		blt	.L16
 2916              		.loc 1 88 0 is_stmt 0 discriminator 1
 2917 01a8 80319FE5 		ldr	r3, .L18+4
 2918 01ac 002093E5 		ldr	r2, [r3, #0]
 2919 01b0 74319FE5 		ldr	r3, .L18
 2920 01b4 023193E7 		ldr	r3, [r3, r2, asl #2]
 2921 01b8 000053E3 		cmp	r3, #0
 2922 01bc 4600001A 		bne	.L17
 2923              	.LBB3:
  89:../keyboard.c **** 	{
  90:../keyboard.c **** 		D8Led_symbol(key);
 2924              		.loc 1 90 0 is_stmt 1
 2925 01c0 68319FE5 		ldr	r3, .L18+4
 2926 01c4 003093E5 		ldr	r3, [r3, #0]
 2927 01c8 0300A0E1 		mov	r0, r3
 2928 01cc FEFFFFEB 		bl	D8Led_symbol
  91:../keyboard.c **** 		//lcd_puts_x2(40,20,0xffffff,"X");
  92:../keyboard.c **** 		tablero[key] = (turno % 2) +1;
 2929              		.loc 1 92 0
 2930 01d0 58319FE5 		ldr	r3, .L18+4
 2931 01d4 001093E5 		ldr	r1, [r3, #0]
 2932 01d8 58319FE5 		ldr	r3, .L18+12
 2933 01dc 002093E5 		ldr	r2, [r3, #0]
 2934 01e0 C23FA0E1 		mov	r3, r2, asr #31
 2935 01e4 A33FA0E1 		mov	r3, r3, lsr #31
 2936 01e8 032082E0 		add	r2, r2, r3
 2937 01ec 012002E2 		and	r2, r2, #1
 2938 01f0 023063E0 		rsb	r3, r3, r2
 2939 01f4 012083E2 		add	r2, r3, #1
 2940 01f8 2C319FE5 		ldr	r3, .L18
 2941 01fc 012183E7 		str	r2, [r3, r1, asl #2]
  93:../keyboard.c **** 		for (i = 0; i < 9; i++){
 2942              		.loc 1 93 0
 2943 0200 0030A0E3 		mov	r3, #0
 2944 0204 20300BE5 		str	r3, [fp, #-32]
 2945 0208 0C0000EA 		b	.L10
 2946              	.L11:
  94:../keyboard.c **** 			aux[i] = tablero[i];
 2947              		.loc 1 94 0 discriminator 2
 2948 020c 18319FE5 		ldr	r3, .L18
 2949 0210 20201BE5 		ldr	r2, [fp, #-32]
 2950 0214 022193E7 		ldr	r2, [r3, r2, asl #2]
 2951 0218 20101BE5 		ldr	r1, [fp, #-32]
 2952 021c 3330E0E3 		mvn	r3, #51
 2953 0220 0111A0E1 		mov	r1, r1, asl #2
 2954 0224 1C004BE2 		sub	r0, fp, #28
 2955 0228 011080E0 		add	r1, r0, r1
 2956 022c 033081E0 		add	r3, r1, r3
 2957 0230 002083E5 		str	r2, [r3, #0]
  93:../keyboard.c **** 		for (i = 0; i < 9; i++){
 2958              		.loc 1 93 0 discriminator 2
 2959 0234 20301BE5 		ldr	r3, [fp, #-32]
 2960 0238 013083E2 		add	r3, r3, #1
 2961 023c 20300BE5 		str	r3, [fp, #-32]
 2962              	.L10:
  93:../keyboard.c **** 		for (i = 0; i < 9; i++){
 2963              		.loc 1 93 0 is_stmt 0 discriminator 1
 2964 0240 20301BE5 		ldr	r3, [fp, #-32]
 2965 0244 080053E3 		cmp	r3, #8
 2966 0248 EFFFFFDA 		ble	.L11
  95:../keyboard.c **** 		}
  96:../keyboard.c **** 		Uart1_SendByte(key);
 2967              		.loc 1 96 0 is_stmt 1
 2968 024c DC309FE5 		ldr	r3, .L18+4
 2969 0250 003093E5 		ldr	r3, [r3, #0]
 2970 0254 0300A0E1 		mov	r0, r3
 2971 0258 FEFFFFEB 		bl	Uart1_SendByte
  97:../keyboard.c **** 		int h = turno;
 2972              		.loc 1 97 0
 2973 025c D4309FE5 		ldr	r3, .L18+12
 2974 0260 003093E5 		ldr	r3, [r3, #0]
 2975 0264 28300BE5 		str	r3, [fp, #-40]
  98:../keyboard.c **** 		if (turno % 2 == 0){
 2976              		.loc 1 98 0
 2977 0268 C8309FE5 		ldr	r3, .L18+12
 2978 026c 003093E5 		ldr	r3, [r3, #0]
 2979 0270 013003E2 		and	r3, r3, #1
 2980 0274 000053E3 		cmp	r3, #0
 2981 0278 0400001A 		bne	.L12
  99:../keyboard.c **** 			drawO(key);
 2982              		.loc 1 99 0
 2983 027c AC309FE5 		ldr	r3, .L18+4
 2984 0280 003093E5 		ldr	r3, [r3, #0]
 2985 0284 0300A0E1 		mov	r0, r3
 2986 0288 FEFFFFEB 		bl	drawO
 2987 028c 030000EA 		b	.L13
 2988              	.L12:
 100:../keyboard.c **** 		}
 101:../keyboard.c **** 		else {
 102:../keyboard.c **** 			drawX(key);
 2989              		.loc 1 102 0
 2990 0290 98309FE5 		ldr	r3, .L18+4
 2991 0294 003093E5 		ldr	r3, [r3, #0]
 2992 0298 0300A0E1 		mov	r0, r3
 2993 029c FEFFFFEB 		bl	drawX
 2994              	.L13:
 103:../keyboard.c **** 		}
 104:../keyboard.c **** 		h = turno;
 2995              		.loc 1 104 0
 2996 02a0 90309FE5 		ldr	r3, .L18+12
 2997 02a4 003093E5 		ldr	r3, [r3, #0]
 2998 02a8 28300BE5 		str	r3, [fp, #-40]
 105:../keyboard.c **** 		int fin = comprobarFinDelJuego();
 2999              		.loc 1 105 0
 3000 02ac FEFFFFEB 		bl	comprobarFinDelJuego
 3001 02b0 2C000BE5 		str	r0, [fp, #-44]
 106:../keyboard.c **** 
 107:../keyboard.c **** 		if(fin != 0){
 3002              		.loc 1 107 0
 3003 02b4 2C301BE5 		ldr	r3, [fp, #-44]
 3004 02b8 000053E3 		cmp	r3, #0
 3005 02bc 0100000A 		beq	.L14
 3006              	.LBB4:
 108:../keyboard.c **** 			drawFin(fin);
 3007              		.loc 1 108 0
 3008 02c0 2C001BE5 		ldr	r0, [fp, #-44]
 3009 02c4 FEFFFFEB 		bl	drawFin
 3010              	.L14:
 3011              	.LBE4:
 109:../keyboard.c **** 		}
 110:../keyboard.c **** 
 111:../keyboard.c **** 
 112:../keyboard.c **** 		DelayMs(1);
 3012              		.loc 1 112 0
 3013 02c8 0100A0E3 		mov	r0, #1
 3014 02cc FEFFFFEB 		bl	DelayMs
 3015              	.LBE3:
 113:../keyboard.c **** 	}
 114:../keyboard.c **** 	/* Esperar a se libere la tecla: consultar bit 1 del registro de datos del puerto G */
 115:../keyboard.c **** 	while ((rPDATG & 0x00000002) == 0 ){ // Que está pulsada la tecla
 3016              		.loc 1 115 0
 3017 02d0 020000EA 		b	.L15
 3018              	.L16:
 3019 02d4 0000A0E1 		mov	r0, r0	@ nop
 3020 02d8 000000EA 		b	.L15
 3021              	.L17:
 3022 02dc 0000A0E1 		mov	r0, r0	@ nop
 3023              	.L15:
 3024              		.loc 1 115 0 is_stmt 0 discriminator 1
 3025 02e0 54309FE5 		ldr	r3, .L18+16
 3026 02e4 003093E5 		ldr	r3, [r3, #0]
 3027 02e8 023003E2 		and	r3, r3, #2
 3028 02ec 000053E3 		cmp	r3, #0
 3029 02f0 FAFFFF0A 		beq	.L15
 116:../keyboard.c **** 		//NOTHING
 117:../keyboard.c **** 	}
 118:../keyboard.c **** 	/* Esperar trd mediante la funcion Delay() */
 119:../keyboard.c **** 	DelayMs(100);
 3030              		.loc 1 119 0 is_stmt 1
 3031 02f4 6400A0E3 		mov	r0, #100
 3032 02f8 FEFFFFEB 		bl	DelayMs
 120:../keyboard.c **** 
 121:../keyboard.c **** 	/* Borrar interrupción de teclado */
 122:../keyboard.c **** 	rI_ISPC = BIT_EINT1; // ????
 3033              		.loc 1 122 0
 3034 02fc 3C309FE5 		ldr	r3, .L18+20
 3035 0300 0124A0E3 		mov	r2, #16777216
 3036 0304 002083E5 		str	r2, [r3, #0]
 123:../keyboard.c **** 
 124:../keyboard.c **** 	turno = turno + 1;
 3037              		.loc 1 124 0
 3038 0308 28309FE5 		ldr	r3, .L18+12
 3039 030c 003093E5 		ldr	r3, [r3, #0]
 3040 0310 012083E2 		add	r2, r3, #1
 3041 0314 1C309FE5 		ldr	r3, .L18+12
 3042 0318 002083E5 		str	r2, [r3, #0]
 125:../keyboard.c **** }
 3043              		.loc 1 125 0
 3044 031c 1CD04BE2 		sub	sp, fp, #28
 3045 0320 0F689DE8 		ldmfd	sp, {r0, r1, r2, r3, fp, sp, lr}
 3046 0324 04C09DE4 		ldmfd	sp!, {ip}
 3047 0328 04F05EE2 		subs	pc, lr, #4
 3048              	.L19:
 3049              		.align	2
 3050              	.L18:
 3051 032c 00000000 		.word	tablero
 3052 0330 00000000 		.word	key
 3053 0334 00000000 		.word	NCOL
 3054 0338 00000000 		.word	turno
 3055 033c 4400D201 		.word	30539844
 3056 0340 2400E001 		.word	31457316
 3057              		.cfi_endproc
 3058              	.LFE1:
 3060              		.align	2
 3061              		.global	key_read
 3063              	key_read:
 3064              	.LFB2:
 126:../keyboard.c **** 
 127:../keyboard.c **** /*---- OJO HARDCODEADO PARA QUE SEA UNA MATRIZ DE 3X3 ---*/
 128:../keyboard.c **** int key_read()
 129:../keyboard.c **** {
 3065              		.loc 1 129 0
 3066              		.cfi_startproc
 3067              		@ Function supports interworking.
 3068              		@ args = 0, pretend = 0, frame = 8
 3069              		@ frame_needed = 1, uses_anonymous_args = 0
 3070 0344 0DC0A0E1 		mov	ip, sp
 3071              	.LCFI4:
 3072              		.cfi_def_cfa_register 12
 3073 0348 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3074 034c 04B04CE2 		sub	fp, ip, #4
 3075              		.cfi_offset 14, -8
 3076              		.cfi_offset 13, -12
 3077              		.cfi_offset 11, -16
 3078              	.LCFI5:
 3079              		.cfi_def_cfa 11, 4
 3080 0350 08D04DE2 		sub	sp, sp, #8
 130:../keyboard.c **** 	int value= -1;
 3081              		.loc 1 130 0
 3082 0354 0030E0E3 		mvn	r3, #0
 3083 0358 10300BE5 		str	r3, [fp, #-16]
 131:../keyboard.c **** 	char temp;
 132:../keyboard.c **** 	// Identificar la tecla mediante ''scanning''
 133:../keyboard.c **** 	// Si la identificación falla la función debe devolver -1
 134:../keyboard.c **** 	temp = *(keyboard_base + 0xfd) & KEY_VALUE_MASK;
 3084              		.loc 1 134 0
 3085 035c 0C329FE5 		ldr	r3, .L45
 3086 0360 003093E5 		ldr	r3, [r3, #0]
 3087 0364 FD3083E2 		add	r3, r3, #253
 3088 0368 0030D3E5 		ldrb	r3, [r3, #0]
 3089 036c FF3003E2 		and	r3, r3, #255
 3090 0370 0F3003E2 		and	r3, r3, #15
 3091 0374 11304BE5 		strb	r3, [fp, #-17]
 135:../keyboard.c **** 	//Usamos KEY_VALUE_MASK para quedarnos con los 4 bits menos significativos
 136:../keyboard.c **** 
 137:../keyboard.c **** 	switch (temp) {
 3092              		.loc 1 137 0
 3093 0378 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 3094 037c 073043E2 		sub	r3, r3, #7
 3095 0380 070053E3 		cmp	r3, #7
 3096 0384 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3097 0388 130000EA 		b	.L21
 3098              	.L26:
 3099 038c AC030000 		.word	.L22
 3100 0390 DC030000 		.word	.L21
 3101 0394 DC030000 		.word	.L21
 3102 0398 DC030000 		.word	.L21
 3103 039c B8030000 		.word	.L23
 3104 03a0 DC030000 		.word	.L21
 3105 03a4 C4030000 		.word	.L24
 3106 03a8 D0030000 		.word	.L25
 3107              	.L22:
 138:../keyboard.c **** 		case 0x7:  value = 0; break;
 3108              		.loc 1 138 0
 3109 03ac 0030A0E3 		mov	r3, #0
 3110 03b0 10300BE5 		str	r3, [fp, #-16]
 3111 03b4 080000EA 		b	.L21
 3112              	.L23:
 139:../keyboard.c **** 		case 0xB:  value = 1; break;
 3113              		.loc 1 139 0
 3114 03b8 0130A0E3 		mov	r3, #1
 3115 03bc 10300BE5 		str	r3, [fp, #-16]
 3116 03c0 050000EA 		b	.L21
 3117              	.L24:
 140:../keyboard.c **** 		case 0xD:  value = 2; break;
 3118              		.loc 1 140 0
 3119 03c4 0230A0E3 		mov	r3, #2
 3120 03c8 10300BE5 		str	r3, [fp, #-16]
 3121 03cc 020000EA 		b	.L21
 3122              	.L25:
 141:../keyboard.c **** 		case 0xE:  value = 15; break;
 3123              		.loc 1 141 0
 3124 03d0 0F30A0E3 		mov	r3, #15
 3125 03d4 10300BE5 		str	r3, [fp, #-16]
 3126 03d8 0000A0E1 		mov	r0, r0	@ nop
 3127              	.L21:
 142:../keyboard.c **** 	}
 143:../keyboard.c **** 
 144:../keyboard.c **** 	temp = *(keyboard_base + 0xfb) & KEY_VALUE_MASK;
 3128              		.loc 1 144 0
 3129 03dc 8C319FE5 		ldr	r3, .L45
 3130 03e0 003093E5 		ldr	r3, [r3, #0]
 3131 03e4 FB3083E2 		add	r3, r3, #251
 3132 03e8 0030D3E5 		ldrb	r3, [r3, #0]
 3133 03ec FF3003E2 		and	r3, r3, #255
 3134 03f0 0F3003E2 		and	r3, r3, #15
 3135 03f4 11304BE5 		strb	r3, [fp, #-17]
 145:../keyboard.c **** 	//Usamos KEY_VALUE_MASK para quedarnos con los 4 bits menos significativos
 146:../keyboard.c **** 
 147:../keyboard.c **** 	switch (temp) {
 3136              		.loc 1 147 0
 3137 03f8 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 3138 03fc 073043E2 		sub	r3, r3, #7
 3139 0400 070053E3 		cmp	r3, #7
 3140 0404 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3141 0408 130000EA 		b	.L27
 3142              	.L32:
 3143 040c 2C040000 		.word	.L28
 3144 0410 5C040000 		.word	.L27
 3145 0414 5C040000 		.word	.L27
 3146 0418 5C040000 		.word	.L27
 3147 041c 38040000 		.word	.L29
 3148 0420 5C040000 		.word	.L27
 3149 0424 44040000 		.word	.L30
 3150 0428 50040000 		.word	.L31
 3151              	.L28:
 148:../keyboard.c **** 		case 0x7:  value = 3; break;
 3152              		.loc 1 148 0
 3153 042c 0330A0E3 		mov	r3, #3
 3154 0430 10300BE5 		str	r3, [fp, #-16]
 3155 0434 080000EA 		b	.L27
 3156              	.L29:
 149:../keyboard.c **** 		case 0xB:  value = 4; break;
 3157              		.loc 1 149 0
 3158 0438 0430A0E3 		mov	r3, #4
 3159 043c 10300BE5 		str	r3, [fp, #-16]
 3160 0440 050000EA 		b	.L27
 3161              	.L30:
 150:../keyboard.c **** 		case 0xD:  value = 5; break;
 3162              		.loc 1 150 0
 3163 0444 0530A0E3 		mov	r3, #5
 3164 0448 10300BE5 		str	r3, [fp, #-16]
 3165 044c 020000EA 		b	.L27
 3166              	.L31:
 151:../keyboard.c **** 		case 0xE:  value = 15; break;
 3167              		.loc 1 151 0
 3168 0450 0F30A0E3 		mov	r3, #15
 3169 0454 10300BE5 		str	r3, [fp, #-16]
 3170 0458 0000A0E1 		mov	r0, r0	@ nop
 3171              	.L27:
 152:../keyboard.c **** 	}
 153:../keyboard.c **** 
 154:../keyboard.c **** 	temp = *(keyboard_base + 0xf7) & KEY_VALUE_MASK;
 3172              		.loc 1 154 0
 3173 045c 0C319FE5 		ldr	r3, .L45
 3174 0460 003093E5 		ldr	r3, [r3, #0]
 3175 0464 F73083E2 		add	r3, r3, #247
 3176 0468 0030D3E5 		ldrb	r3, [r3, #0]
 3177 046c FF3003E2 		and	r3, r3, #255
 3178 0470 0F3003E2 		and	r3, r3, #15
 3179 0474 11304BE5 		strb	r3, [fp, #-17]
 155:../keyboard.c **** 	//Usamos KEY_VALUE_MASK para quedarnos con los 4 bits menos significativos
 156:../keyboard.c **** 
 157:../keyboard.c **** 	switch (temp) {
 3180              		.loc 1 157 0
 3181 0478 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 3182 047c 073043E2 		sub	r3, r3, #7
 3183 0480 070053E3 		cmp	r3, #7
 3184 0484 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3185 0488 130000EA 		b	.L33
 3186              	.L38:
 3187 048c AC040000 		.word	.L34
 3188 0490 DC040000 		.word	.L33
 3189 0494 DC040000 		.word	.L33
 3190 0498 DC040000 		.word	.L33
 3191 049c B8040000 		.word	.L35
 3192 04a0 DC040000 		.word	.L33
 3193 04a4 C4040000 		.word	.L36
 3194 04a8 D0040000 		.word	.L37
 3195              	.L34:
 158:../keyboard.c **** 		case 0x7:  value = 6; break;
 3196              		.loc 1 158 0
 3197 04ac 0630A0E3 		mov	r3, #6
 3198 04b0 10300BE5 		str	r3, [fp, #-16]
 3199 04b4 080000EA 		b	.L33
 3200              	.L35:
 159:../keyboard.c **** 		case 0xB:  value = 7; break;
 3201              		.loc 1 159 0
 3202 04b8 0730A0E3 		mov	r3, #7
 3203 04bc 10300BE5 		str	r3, [fp, #-16]
 3204 04c0 050000EA 		b	.L33
 3205              	.L36:
 160:../keyboard.c **** 		case 0xD:  value = 8; break;
 3206              		.loc 1 160 0
 3207 04c4 0830A0E3 		mov	r3, #8
 3208 04c8 10300BE5 		str	r3, [fp, #-16]
 3209 04cc 020000EA 		b	.L33
 3210              	.L37:
 161:../keyboard.c **** 		case 0xE:  value = 15; break;
 3211              		.loc 1 161 0
 3212 04d0 0F30A0E3 		mov	r3, #15
 3213 04d4 10300BE5 		str	r3, [fp, #-16]
 3214 04d8 0000A0E1 		mov	r0, r0	@ nop
 3215              	.L33:
 162:../keyboard.c **** 	}
 163:../keyboard.c **** 
 164:../keyboard.c **** 	temp = *(keyboard_base + 0xef) & KEY_VALUE_MASK;
 3216              		.loc 1 164 0
 3217 04dc 8C309FE5 		ldr	r3, .L45
 3218 04e0 003093E5 		ldr	r3, [r3, #0]
 3219 04e4 EF3083E2 		add	r3, r3, #239
 3220 04e8 0030D3E5 		ldrb	r3, [r3, #0]
 3221 04ec FF3003E2 		and	r3, r3, #255
 3222 04f0 0F3003E2 		and	r3, r3, #15
 3223 04f4 11304BE5 		strb	r3, [fp, #-17]
 165:../keyboard.c **** 	//Usamos KEY_VALUE_MASK para quedarnos con los 4 bits menos significativos
 166:../keyboard.c **** 
 167:../keyboard.c **** 	switch (temp) {
 3224              		.loc 1 167 0
 3225 04f8 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 3226 04fc 073043E2 		sub	r3, r3, #7
 3227 0500 070053E3 		cmp	r3, #7
 3228 0504 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3229 0508 130000EA 		b	.L39
 3230              	.L44:
 3231 050c 2C050000 		.word	.L40
 3232 0510 5C050000 		.word	.L39
 3233 0514 5C050000 		.word	.L39
 3234 0518 5C050000 		.word	.L39
 3235 051c 38050000 		.word	.L41
 3236 0520 5C050000 		.word	.L39
 3237 0524 44050000 		.word	.L42
 3238 0528 50050000 		.word	.L43
 3239              	.L40:
 168:../keyboard.c **** 		case 0x7:  value = 15; break;
 3240              		.loc 1 168 0
 3241 052c 0F30A0E3 		mov	r3, #15
 3242 0530 10300BE5 		str	r3, [fp, #-16]
 3243 0534 080000EA 		b	.L39
 3244              	.L41:
 169:../keyboard.c **** 		case 0xB:  value = 15; break;
 3245              		.loc 1 169 0
 3246 0538 0F30A0E3 		mov	r3, #15
 3247 053c 10300BE5 		str	r3, [fp, #-16]
 3248 0540 050000EA 		b	.L39
 3249              	.L42:
 170:../keyboard.c **** 		case 0xD:  value = 15; break;
 3250              		.loc 1 170 0
 3251 0544 0F30A0E3 		mov	r3, #15
 3252 0548 10300BE5 		str	r3, [fp, #-16]
 3253 054c 020000EA 		b	.L39
 3254              	.L43:
 171:../keyboard.c **** 		case 0xE:  value = 15; break;
 3255              		.loc 1 171 0
 3256 0550 0F30A0E3 		mov	r3, #15
 3257 0554 10300BE5 		str	r3, [fp, #-16]
 3258 0558 0000A0E1 		mov	r0, r0	@ nop
 3259              	.L39:
 172:../keyboard.c **** 	}
 173:../keyboard.c **** 
 174:../keyboard.c **** 	return value;
 3260              		.loc 1 174 0
 3261 055c 10301BE5 		ldr	r3, [fp, #-16]
 175:../keyboard.c **** 
 176:../keyboard.c **** }
 3262              		.loc 1 176 0
 3263 0560 0300A0E1 		mov	r0, r3
 3264 0564 0CD04BE2 		sub	sp, fp, #12
 3265 0568 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3266 056c 1EFF2FE1 		bx	lr
 3267              	.L46:
 3268              		.align	2
 3269              	.L45:
 3270 0570 00000000 		.word	keyboard_base
 3271              		.cfi_endproc
 3272              	.LFE2:
 3274              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 keyboard.c
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:2733   .data:00000000 keyboard_base
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:2730   .data:00000000 $d
                            *COM*:00000004 key
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:2737   .text:00000000 $a
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:2740   .text:00000000 keyboard_init
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:2804   .text:00000094 $d
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:2819   .text:000000b8 KeyboardInt
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:2816   .text:000000b8 $a
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:3063   .text:00000344 key_read
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:3051   .text:0000032c $d
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:3060   .text:00000344 $a
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:3099   .text:0000038c $d
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:3109   .text:000003ac $a
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:3143   .text:0000040c $d
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:3153   .text:0000042c $a
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:3187   .text:0000048c $d
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:3197   .text:000004ac $a
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:3231   .text:0000050c $d
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:3241   .text:0000052c $a
C:\Users\Paloma\AppData\Local\Temp\ccMfumn3.s:3270   .text:00000570 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
DelayMs
D8Led_symbol
Uart1_SendByte
drawO
drawX
comprobarFinDelJuego
drawFin
tablero
NCOL
turno
